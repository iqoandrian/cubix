<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Play Cubooz</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Inter', sans-serif; color: white; }
        canvas { display: block; }

        .overlay-ui { position: absolute; padding: 10px 20px; background-color: rgba(0, 0, 0, 0.65); border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); font-size: 1rem; font-weight: 600; text-align: center; border: 1px solid rgba(255, 255, 255, 0.08); backdrop-filter: blur(4px); display: flex; gap: 12px; align-items:center; }
        #game-info { top: 20px; left: 50%; transform: translateX(-50%); }

        /* Progress bar */
        .time-bar-wrapper { width: 220px; height: 14px; background: rgba(255,255,255,0.06); border-radius: 12px; overflow: hidden; border: 1px solid rgba(255,255,255,0.06); }
        .time-bar { height:100%; width:100%; background: linear-gradient(90deg, #84cc16, #10b981); transform-origin: left; transition: width 0.25s linear; }

        .message-box { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 36px; text-align: center; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); width: 92%; max-width: 520px; background-color: rgba(0, 0, 0, 0.85); backdrop-filter: blur(8px); border: 1px solid rgba(255, 255, 255, 0.08); }
        .title { font-size: 2.2rem; font-weight: 800; color: #e6edf3; }
        .btn { background-color: #334155; padding: 12px 22px; border-radius: 10px; font-size: 1.05rem; font-weight: 700; margin-top: 18px; cursor: pointer; transition: background-color 0.18s, transform 0.12s; color: #f8fafc; border: 1px solid rgba(255,255,255,0.04); }
        .btn:hover { background-color: #1f2937; transform: translateY(-2px); }

        #mute-btn { position: absolute; bottom: 20px; right: 20px; width: 52px; height: 52px; background-color: rgba(0, 0, 0, 0.7); border: 1px solid rgba(255,255,255,0.08); border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: 100; }

        /* Floating score text (DOM-based) */
        .floating-score {
            position: absolute;
            pointer-events: none;
            font-weight: 800;
            font-size: 18px;
            color: #bbf7d0;
            text-shadow: 0 4px 10px rgba(0,0,0,0.6);
            transform: translate(-50%, -50%) translateY(0);
            opacity: 1;
            transition: transform 900ms cubic-bezier(.2,.9,.2,1), opacity 900ms linear;
            z-index: 110;
        }
        
        /* Floating time freeze text */
        .time-freeze-text {
            color: #60a5fa;
            font-size: 1.5rem;
            font-weight: 900;
            text-shadow: 0 0 10px #60a5fa, 0 0 20px #60a5fa;
            position: absolute;
            top: 75px;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            animation: fadeInOut 3s forwards;
            pointer-events: none;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Small responsive tweak */
        @media (max-width: 420px) {
            .overlay-ui { gap: 8px; padding: 8px 12px; font-size: 0.95rem; }
            .time-bar-wrapper { width: 160px; height: 12px; }
            .title { font-size: 1.6rem; }
            .time-freeze-text { font-size: 1.25rem; }
        }
    </style>
</head>
<body>
    <div id="game-ui" class="hidden">
        <div id="game-info" class="overlay-ui">
            <div id="score-board">Skor: 0</div>
            <div class="time-bar-wrapper" title="Waktu tersisa">
                <div id="time-bar" class="time-bar" style="width:100%"></div>
            </div>
            <div id="timer">Waktu: 120</div>
            <div id="difficulty-display">Level: -</div>
        </div>
    </div>

    <div id="start-message" class="message-box flex-col items-center">
        <span class="title">Cubooz</span>
        <p class="mt-4 text-lg">Hancurkan sisi kubus yang berwarna hijau! Hati-hati dengan bom!</p>
        <button id="start-btn" class="btn">Mulai Game</button>
        <button id="rules-btn" class="btn">Aturan Permainan</button>
    </div>
    <div id="rules-message" class="message-box hidden flex-col items-center">
        <span class="title">Aturan Permainan</span>
        <p class="mt-4 text-left w-full text-sm">
            Tujuan Anda adalah menghancurkan semua sisi kubus hijau secepat mungkin untuk naik level.<br><br>
            <b>Aturan:</b>
            <ul class="list-disc list-inside mt-2 text-left w-full">
                <li>Klik atau sentuh sisi hijau untuk dihancurkan. Skor Anda bertambah +2.</li>
                <li>Menyentuh sisi hitam akan mengurangi skor Anda -1 dan mengurangi waktu -1 detik.</li>
                <li>Kubus merah adalah bom! Hancurkan untuk menghancurkan semua kubus di sekitarnya.</li>
                <li>Kubus biru akan membekukan waktu selama 3 detik.</li>
                <li>Setelah semua kubus hijau hancur, Anda naik ke level berikutnya dengan kesulitan yang meningkat.</li>
            </ul>
        </p>
        <button id="close-rules-btn" class="btn">Tutup</button>
    </div>
    <div id="level-complete-message" class="message-box hidden flex-col items-center">
        <span class="title">Level Selesai!</span>
        <p id="level-score-breakdown" class="mt-4 text-lg"></p>
        <button id="continue-btn" class="btn">Lanjut ke Level Berikutnya</button>
    </div>
    <div id="win-message" class="message-box hidden flex-col items-center">
        <span class="title">Selamat!</span>
        <p class="mt-2 text-lg">Anda telah menyelesaikan semua level!</p>
        <p id="final-score" class="mt-4 text-2xl font-bold"></p>
        <button class="btn" onclick="restartGame()">Main Lagi</button>
    </div>
    <div id="lose-message" class="message-box hidden flex-col items-center">
        <span class="title">Waktu Habis!</span>
        <p id="lose-score" class="mt-4 text-2xl font-bold"></p>
        <button class="btn" onclick="restartGame()">Coba Lagi</button>
    </div>

    <button id="mute-btn">
        <svg id="unmuted-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
        <svg id="muted-icon" class="hidden" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>
    </button>

    <!-- Container untuk floating score DOM elements -->
    <div id="floating-container" style="position: absolute; left:0; top:0; width:100%; height:100%; pointer-events:none;"></div>

    <script>
        // --- Global ---
        let scene, camera, renderer, cubeGroup, starfield;
        let totalScore = 0, timer = 120, initialTimer = 120, gameInterval = null, destroyedThisLevel = 0;
        const size = 4; // 4x4x4
        const totalCubes = size * size * size;
        let isGameOver = true, isMuted = false, isTimeFrozen = false;
        let particles = [];
        const maxLevels = 5; // A.k.a level 1 to 5
        let currentLevelIndex = 0;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let synths = {};

        // --- Init & animate ---
        initScene();
        animate();

        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 9; // Changed from 12 to 9 for a closer view
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio || 1);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('pointerdown', onPointerDown);
            renderer.domElement.addEventListener('pointermove', onPointerMove);
            renderer.domElement.addEventListener('pointerup', onPointerUp);
            // Fix bug: Prevent right-click/long-press context menu
            renderer.domElement.addEventListener('contextmenu', (event) => event.preventDefault());

            document.getElementById('mute-btn').addEventListener('click', toggleMute);
            document.getElementById('continue-btn').addEventListener('click', loadNextLevel);
            document.getElementById('start-btn').addEventListener('click', async () => {
                document.getElementById('start-message').classList.add('hidden');
                await initAudio();
                startGame();
            });
            document.getElementById('rules-btn').addEventListener('click', () => {
                document.getElementById('start-message').classList.add('hidden');
                document.getElementById('rules-message').classList.remove('hidden');
            });
            document.getElementById('close-rules-btn').addEventListener('click', () => {
                document.getElementById('rules-message').classList.add('hidden');
                document.getElementById('start-message').classList.remove('hidden');
            });
        }

        async function initAudio() {
            // Start audio context after user gesture
            await Tone.start();
            synths.explosion = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.002, decay: 0.12, sustain: 0, release: 0.18 } }).toDestination();
            synths.bomb = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 8, oscillator: { type: "sine" }, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.0 } }).toDestination();
            synths.time = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 0.4 } }).toDestination();
            synths.error = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.12, sustain: 0, release: 0.1 } }).toDestination();
            Tone.Destination.volume.value = isMuted ? -Infinity : 0;
        }

        function restartGame() {
            // Reset game state
            totalScore = 0;
            currentLevelIndex = 0;
            isGameOver = false;
            
            // Hide all message boxes
            document.getElementById('win-message').classList.add('hidden');
            document.getElementById('lose-message').classList.add('hidden');
            document.getElementById('start-message').classList.remove('hidden');
        }

        // --- Game control ---
        function startGame() {
            isGameOver = false;
            document.getElementById('game-ui').classList.remove('hidden');
            destroyedThisLevel = 0;

            // timer by difficulty (can be tuned)
            initialTimer = 120 - (currentLevelIndex * 15);
            timer = initialTimer;
            updateUI();

            if (gameInterval) clearInterval(gameInterval);
            gameInterval = setInterval(updateTimer, 1000);

            Tone.Transport.start();

            if (!starfield) createStarfield();
            createRubikCube();
        }

        function updateTimer() {
            if (isTimeFrozen) {
                return;
            }
            timer--;
            updateUI();
            if (timer <= 0) {
                gameOver(false);
            }
        }

        function levelComplete() {
            isGameOver = true;
            clearInterval(gameInterval);
            Tone.Transport.stop();
            const timeBonus = timer;
            totalScore += timeBonus;
            document.getElementById('game-ui').classList.add('hidden');
            // Update the title with the current level number
            document.querySelector('#level-complete-message .title').innerText = `Level ${currentLevelIndex + 1} Selesai!`;
            document.getElementById('level-score-breakdown').innerHTML = `Bonus Waktu: ${timeBonus} Poin<br>Total Skor Saat Ini: ${totalScore}`;
            document.getElementById('level-complete-message').classList.remove('hidden');
        }

        function loadNextLevel() {
            document.getElementById('level-complete-message').classList.add('hidden');
            currentLevelIndex++;
            if (currentLevelIndex < maxLevels) startGame();
            else gameOver(true);
        }

        function gameOver(isWin) {
            isGameOver = true;
            clearInterval(gameInterval);
            Tone.Transport.stop();
            document.getElementById('game-ui').classList.add('hidden');
            if (isWin) {
                document.getElementById('final-score').innerText = `Skor Akhir Anda: ${totalScore}`;
                document.getElementById('win-message').classList.remove('hidden');
            } else {
                document.getElementById('lose-score').innerText = `Skor Akhir Anda: ${totalScore}`;
                document.getElementById('lose-message').classList.remove('hidden');
            }
        }

        function updateUI() {
            document.getElementById('score-board').innerText = `Skor: ${totalScore}`;
            document.getElementById('timer').innerText = `Waktu: ${timer}`;
            document.getElementById('difficulty-display').innerText = `Level: ${currentLevelIndex + 1}`;

            const ratio = Math.max(0, Math.min(1, timer / initialTimer));
            const bar = document.getElementById('time-bar');
            bar.style.width = (ratio * 100) + '%';
            // change bar color a bit depending on ratio
            if (ratio > 0.5) bar.style.background = 'linear-gradient(90deg, #84cc16, #10b981)';
            else if (ratio > 0.25) bar.style.background = 'linear-gradient(90deg, #f59e0b, #f97316)';
            else bar.style.background = 'linear-gradient(90deg, #ef4444, #dc2626)';
        }

        // --- 3D objects ---
        function createStarfield() {
            const starCount = 2000;
            const starGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);
            const color = new THREE.Color();
            for (let i = 0; i < starCount; i++) {
                positions[i * 3] = THREE.MathUtils.randFloatSpread(200);
                positions[i * 3 + 1] = THREE.MathUtils.randFloatSpread(200);
                positions[i * 3 + 2] = THREE.MathUtils.randFloatSpread(200);
                color.setHSL(0.6, 0.2, Math.random() * 0.5 + 0.5);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const starMaterial = new THREE.PointsMaterial({ size: 0.09, sizeAttenuation: true, transparent: true, vertexColors: true });
            starfield = new THREE.Points(starGeometry, starMaterial);
            scene.add(starfield);
        }

        function createRubikCube() {
            if (cubeGroup) {
                scene.remove(cubeGroup);
                disposeGroup(cubeGroup);
            }
            particles.forEach(p => scene.remove(p.mesh));
            particles = [];

            cubeGroup = new THREE.Group();
            const spacing = 1.05, cubeSize = 1;
            const offset = (size - 1) * spacing / 2;
            const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            
            // green face props per difficulty
            const greenProps = { 
                color: 0x22c55e, 
                transparent: true, 
                opacity: Math.max(0.4, 1.0 - (currentLevelIndex * 0.15)) 
            };
            
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    for (let k = 0; k < size; k++) {
                        // create 6 separate black materials for faces so modifying one won't change others
                        const materials = [];
                        for (let m = 0; m < 6; m++) {
                            materials.push(new THREE.MeshStandardMaterial({ color: 0x0b0f13, roughness: 0.6, metalness: 0.0, name: 'black' }));
                        }

                        const faceIndex = Math.floor(Math.random() * 6);
                        const cube = new THREE.Mesh(geometry, materials);
                        cube.position.set(i * spacing - offset, j * spacing - offset, k * spacing - offset);
                        cube.isSolved = false;
                        cube.greenFaceIndex = faceIndex;
                        cube.gridPos = { i, j, k };

                        const rand = Math.random();
                        if (rand < 0.05) {
                            cube.type = 'bomb';
                            cube.material[faceIndex] = new THREE.MeshStandardMaterial({ color: 0xef4444, emissive: 0x550000, metalness: 0.2, name: 'special' });
                        } else if (rand < 0.10) {
                            cube.type = 'time';
                            cube.material[faceIndex] = new THREE.MeshStandardMaterial({ color: 0x3b82f6, emissive: 0x001a55, metalness: 0.1, name: 'special' });
                        } else {
                            cube.type = 'normal';
                            cube.material[faceIndex] = new THREE.MeshStandardMaterial({ color: greenProps.color, transparent: greenProps.transparent, opacity: greenProps.opacity, emissive: greenProps.color * 0.1, name: 'special' });
                        }
                        cubeGroup.add(cube);
                    }
                }
            }

            // scale cubeGroup to fit smaller screens
            const minDim = Math.min(window.innerWidth, window.innerHeight);
            const targetScale = Math.min(1.0, Math.max(0.6, minDim / 900));
            cubeGroup.scale.setScalar(targetScale);

            scene.add(cubeGroup);
        }

        // dispose helpers to avoid memory leaks
        function disposeMaterial(mat) {
            try { if (mat.map) mat.map.dispose(); } catch (e){}
            try { mat.dispose(); } catch (e){}
        }
        function disposeGroup(g) {
            g.traverse(obj => {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (Array.isArray(obj.material)) obj.material.forEach(disposeMaterial);
                    else disposeMaterial(obj.material);
                }
            });
        }

        // --- Gameplay interactions ---
        function handleCubeHit(clickedCube, faceIndex, screenX, screenY) {
            if (isGameOver || clickedCube.isSolved) return;
            // Check if the material name is "special" (the green, red, or blue face)
            if (clickedCube.material[faceIndex].name === 'special') {
                totalScore += 2;
                // show floating +2 at click position
                showFloatingScore('+2', screenX, screenY, '#bbf7d0');

                switch (clickedCube.type) {
                    case 'time': 
                        isTimeFrozen = true;
                        showTimeFreezeText();
                        playSound('time');
                        setTimeout(() => {
                            isTimeFrozen = false;
                            updateUI();
                        }, 3000);
                        destroyCube(clickedCube);
                        break;
                    case 'bomb': 
                        playSound('bomb'); 
                        detonateBomb(clickedCube, screenX, screenY); 
                        break;
                    default: 
                        playSound('explosion'); 
                        destroyCube(clickedCube); 
                        break;
                }
            } else {
                totalScore -= 1;
                timer -= 1;
                showFloatingScore('-1', screenX, screenY, '#fecaca');
                playSound('error');
            }
            updateUI();
        }

        function destroyCube(cube) {
            if (cube.isSolved) return;
            cube.isSolved = true;
            destroyedThisLevel++;
            // get color from material safely
            const mat = cube.material && cube.material[cube.greenFaceIndex] ? cube.material[cube.greenFaceIndex] : null;
            const color = mat && mat.color ? mat.color.getHex() : 0xffffff;
            createExplosion(cube.getWorldPosition(new THREE.Vector3()), color);
            cubeGroup.remove(cube);
            if (destroyedThisLevel >= totalCubes) {
                setTimeout(() => levelComplete(), 250);
            }
        }

        function detonateBomb(bombCube, screenX, screenY) {
            destroyCube(bombCube);
            const { i, j, k } = bombCube.gridPos;
            const cubesToDestroy = [];
            cubeGroup.children.forEach(targetCube => {
                if (targetCube.isSolved) return;
                const { i: ti, j: tj, k: tk } = targetCube.gridPos;
                const dist = Math.max(Math.abs(i - ti), Math.abs(j - tj), Math.abs(k - tk));
                if (dist === 1) cubesToDestroy.push(targetCube);
            });
            cubesToDestroy.forEach((target, index) => {
                setTimeout(() => {
                    if (!target.isSolved) {
                        totalScore += 2;
                        playSound('explosion');
                        // show floating for explosion
                        const screenPos = worldToScreen(target.getWorldPosition(new THREE.Vector3()));
                        showFloatingScore('+2', screenPos.x, screenPos.y, '#ffd7b5');
                        destroyCube(target);
                        updateUI();
                    }
                }, 80 * index);
            });
            // big explosion visual
            showFloatingScore('BOOM', screenX, screenY, '#ffb4b4');
        }

        // --- Particles & explosion ---
        function createExplosion(position, colorHex) {
            const particleCount = 28;
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                // create unique material so opacity can vary per particle
                const mat = new THREE.MeshBasicMaterial({ color: colorHex, transparent: true, opacity: 1.0 });
                const particle = new THREE.Mesh(particleGeometry, mat);
                particle.position.copy(position);
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * (0.6 + Math.random() * 0.8),
                    (Math.random() - 0.25) * (0.6 + Math.random() * 0.8),
                    (Math.random() - 0.5) * (0.6 + Math.random() * 0.8)
                );
                particles.push({ mesh: particle, velocity: velocity, lifetime: 1.0 });
                scene.add(particle);
            }
        }

        function playSound(type) {
            if (isMuted || !synths[type]) return;
            if (type === 'time') synths.time.triggerAttackRelease("C5", "0.35s");
            else if (type === 'error') synths.error.triggerAttackRelease("C2", "0.12s");
            else synths[type].triggerAttackRelease("8n");
        }

        function toggleMute() {
            isMuted = !isMuted;
            const unmutedIcon = document.getElementById('unmuted-icon');
            const mutedIcon = document.getElementById('muted-icon');
            if (isMuted) {
                Tone.Destination.volume.value = -Infinity;
                unmutedIcon.classList.add('hidden');
                mutedIcon.classList.remove('hidden');
            } else {
                Tone.Destination.volume.value = 0;
                unmutedIcon.classList.remove('hidden');
                mutedIcon.classList.add('hidden');
            }
        }

        // --- Input handling (improved drag vs click) ---
        function onPointerDown(event) {
            if (isGameOver) return;
            isDragging = false;
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onPointerMove(event) {
            if (isGameOver || !cubeGroup) return;
            const dx = event.clientX - previousMousePosition.x;
            const dy = event.clientY - previousMousePosition.y;
            // if moved significantly => consider dragging and rotate
            if (!isDragging && (Math.abs(dx) > 4 || Math.abs(dy) > 4)) isDragging = true;
            if (isDragging) {
                cubeGroup.rotation.y += dx * 0.006;
                cubeGroup.rotation.x += dy * 0.006;
                // clamp x rotation to avoid flipping too far
                cubeGroup.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, cubeGroup.rotation.x));
            }
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onPointerUp(event) {
            if (isGameOver) return;
            const dx = Math.abs(event.clientX - previousMousePosition.x);
            const dy = Math.abs(event.clientY - previousMousePosition.y);
            // if not dragging (no significant move) => it's a click
            if (!isDragging && dx < 6 && dy < 6 && cubeGroup) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(cubeGroup.children, true);
                if (intersects.length > 0 && intersects[0].face) {
                    const obj = intersects[0].object;
                    const faceIdx = intersects[0].face.materialIndex;
                    handleCubeHit(obj, faceIdx, event.clientX, event.clientY);
                }
            }
            isDragging = false;
        }

        // --- Floating score (DOM) ---
        function showFloatingScore(text, clientX, clientY, color = '#bbf7d0') {
            const container = document.getElementById('floating-container');
            const el = document.createElement('div');
            el.className = 'floating-score';
            el.style.left = clientX + 'px';
            el.style.top = clientY + 'px';
            el.style.color = color;
            el.innerText = text;
            container.appendChild(el);
            // force reflow then animate
            requestAnimationFrame(() => {
                el.style.transform = 'translate(-50%, -50%) translateY(-64px) scale(1.02)';
                el.style.opacity = '0';
            });
            setTimeout(() => {
                if (el && el.parentNode) el.parentNode.removeChild(el);
            }, 1000);
        }

        function showTimeFreezeText() {
            const container = document.getElementById('floating-container');
            const el = document.createElement('div');
            el.className = 'time-freeze-text';
            el.innerText = 'Waktu Beku';
            container.appendChild(el);
            setTimeout(() => {
                if (el && el.parentNode) el.parentNode.removeChild(el);
            }, 3000);
        }

        // --- Utility: project world -> screen (for showing floating near 3D objects) ---
        function worldToScreen(pos) {
            const vector = pos.clone().project(camera);
            const x = (vector.x + 1) / 2 * window.innerWidth;
            const y = (-vector.y + 1) / 2 * window.innerHeight;
            return { x, y };
        }

        // --- Animation loop ---
        function animate() {
            requestAnimationFrame(animate);
            if (cubeGroup && !isDragging && !isGameOver) {
                cubeGroup.rotation.y += 0.0007;
                cubeGroup.rotation.x += 0.0003;
            }
            if (starfield) starfield.rotation.y += 0.00008;

            // particles physics
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.mesh.position.add(p.velocity);
                // simple drag
                p.velocity.multiplyScalar(0.995);
                // gravity
                p.velocity.y -= 0.002;
                p.lifetime -= 0.016;
                p.mesh.material.opacity = Math.max(0, p.lifetime);
                if (p.lifetime <= 0) {
                    scene.remove(p.mesh);
                    if (p.mesh.geometry) p.mesh.geometry.dispose();
                    if (p.mesh.material) p.mesh.material.dispose();
                    particles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        // --- Helpers ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // make a quick test helper for debugging (optional)
        window._debug = { scene, camera, renderer };
        
        
    </script>
</body>
</html>
